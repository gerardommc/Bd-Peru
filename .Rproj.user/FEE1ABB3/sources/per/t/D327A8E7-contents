names(data)
data<-read.csv('data.for.prevmap.csv')


fit.glm <- glm(cbind(n_bitten,n_sampled-n_bitten)~elevation1 + elevation2  + climate2+climate3 
                                                  +popden + occupation1+occupation2,
                                                  data=data,family=binomial)
summary(fit.glm)

data$sb_logit_p<- log((data$n_bitten + 0.5)/(data$n_sampled - data$n_bitten + 0.5))

coords <- as.matrix(data[,c("cluster_long","cluster_lat")])

vari <- variog(coords=data[,c("cluster_long","cluster_lat")],data=data$sb_logit_p,max.dist=2)
plot(vari,xlab="distance (decimal degrees)")

vari.fit <- variofit(vari,ini.cov.pars=c(0.1,0.5),cov.model="matern",
                     fix.nugget=FALSE,nugget=0.4,fix.kappa=TRUE,kappa=0.5)
vari.fit
lines(vari.fit)
dev.print(tiff, "sb_variogram.tiff", res=600, height=7, width=6, units="in")




#Binomial logistic model-----

par0.1 <- c(coef(fit.glm.2),vari.fit$cov.pars,vari.fit$nugget)     #c(beta,sigma2,phi,tau2)

mcmc.1 <- control.mcmc.MCML(n.sim=50000,burnin=5000,thin=45,h=(1.65)/(nrow(data)^(1/6)))

start.1 <- c(par0.1[10],par0.1[11]/par0.1[9])     #starting values of phi and the relative variance of the nugget effect nu2 respectively

#?binomial.logistic.MCML
fit.MCML.1 <- binomial.logistic.MCML(formula=n_bitten ~ elevation1+elevation2 + climate2 + climate3+ popden + occupation1 + occupation2,
                                     units.m=~ n_sampled,
                                     par0= par0.1,
                                     coords=~cluster_long+ cluster_lat,
                                     data=data,
                                     control.mcmc=mcmc.1,
                                     kappa=0.5,
                                     start.cov.pars=start.1)
summary(fit.MCML.1,log.cov.pars=FALSE)
coef(fit.MCML.1)

par0.1<-coef(fit.MCML.1)
fit.MCML.1 <- binomial.logistic.MCML(formula=n_bitten ~ elevation1+elevation2 + climate2 + climate3+ popden + occupation1 + occupation2,
                                     units.m=~ n_sampled,
                                     par0= par0.1,
                                     coords=~cluster_long+ cluster_lat,
                                     data=data,
                                     control.mcmc=mcmc.1,
                                     kappa=0.5,
                                     start.cov.pars=c(coef(fit.MCML.1)[9],coef(fit.MCML.1)[11])) #select sigma^2 and tau^2
summary(fit.MCML.1,log.cov.pars=FALSE)
coef(fit.MCML.1)


#prediction
grid.pred <- gridpts(grid.pred[chull(grid.pred),],15000)

climate2.new<-extract(raster.climate,grid.pred)    
climate2.new[climate2.new!=2]<-0
climate2.new[climate2.new==2]<-1

climate3.new<-extract(raster.climate,grid.pred)    
climate3.new[climate3.new!=3]<-0
climate3.new[climate3.new==3]<-1


elevation   <- extract(raster.elevation,grid.pred,method="bilinear")
pop_density <- extract(raster.pop_density,grid.pred,method="bilinear")
occupation  <-extract(raster.occupation,grid.pred,method="bilinear")


summary(pop_density)
pop_density.new[pop_density.new>5000]<-5000
which(pop_density.new>5000)

elevation[is.na(elevation)]<-0
elevation1<-elevation
elevation2<-elevation

for(i in 1:length(elevation)){
  
  if (elevation2[i] <160) { 
    elevation2[i]<-0 
  } else {
    elevation2[i]<-elevation2[i]-160 
  }        
}

occupation1<-occupation
occupation2<-occupation

for(i in 1:length(occupation)){
  
  if (occupation2[i] <0.09) { 
    occupation2[i]<-0 
  } else {
    occupation2[i]<-occupation2[i]-0.09 
  }
}

#predicting surface for bites


predictors <- data.frame(elevation1=elevation1,
                         elevation2=elevation2,
                         climate2=climate2,
                         climate3=climate3,
                         popden=pop_density,
                         occupation1=occupation1,
                         occupation2=occupation2)

summary(predictors)


pred.MCML <- spatial.pred.binomial.MCML(fit.MCML.1,
                                        grid.pred=grid.pred,
                                        predictors=predictors,
                                        control.mcmc=mcmc.1,
                                        type="marginal",
                                        scale.predictions="prevalence",
                                        standard.errors=TRUE,
                                        scale.thresholds="prevalence")


plot(pred.MCML ,type="prevalence",summary="predictions",zlim=c(0,0.012),main="Snakebite Incidence Map",col=colorRampPalette(c("green","yellow","orange","red"))(1000))

